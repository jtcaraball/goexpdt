package compute

import (
	"errors"
	"os"

	"github.com/jtcaraball/goexpdt/query"
	"github.com/jtcaraball/goexpdt/query/logop"
)

// OptOutput corresponds to the output of an optimization computation alongside
// additional information about its execution.
type OptOutput struct {
	// Found is true if a partial instance was computed.
	Found bool
	// Value of the partial instance computed.
	Value query.QConst
	// Calls made to the SAT solver during the computation process.
	Calls int
}

type (
	// VCOrder is a constructor for an encodable formula representing a partial
	// strict order between instances represented as a query variable and a
	// query constant.
	// If the formula contains a "For All Guarded" operator there is no
	// guarantee that the computation will conclude in a polynomial amount of
	// steps and if the order is not strict then computation WILL NOT end at
	// all.
	VCOrder func(v query.QVar, c query.QConst) Encodable
	// SVFormula is a constructor for a single variable formula.
	SVFormula func(v query.QVar) Encodable
)

// ComputeOptim computes the optimal instance that satisfies the formula
// generated by fg according to the order generated by og.
// A target query variable v must be provided in order to ensure there are no
// collisions with variables used by the formulas generated by fg and og.
func ComputeOptim(
	fg SVFormula,
	og VCOrder,
	v query.QVar,
	ctx query.QContext,
	solver Solver,
) (OptOutput, error) {
	var bm []query.QConst

	tmpfp, err := os.CreateTemp("", "tmp.cnf")
	if err != nil {
		return OptOutput{}, nil
	}
	defer func() {
		tmpfp.Close()
		os.Remove(tmpfp.Name())
	}()

	if err = solver.Step(logop.WithVar{I: v, Q: fg(v)}, ctx); err != nil {
		if errors.Is(err, UnsatError) {
			return OptOutput{false, query.QConst{}, 1}, nil
		}

		return OptOutput{false, query.QConst{}, 0}, err
	}

	steps := 1

	for {
		steps += 1

		bm, err = solver.Values([]query.QVar{v}, ctx)
		if err != nil {
			return OptOutput{false, query.QConst{}, 0}, err
		}

		ctx.Reset()

		err = solver.Step(
			logop.WithVar{
				I: v,
				Q: logop.And{
					Q1: fg(v),
					Q2: og(v, bm[0]),
				},
			},
			ctx,
		)
		if err != nil {
			if errors.Is(err, UnsatError) {
				break
			}
			return OptOutput{false, query.QConst{}, 0}, err
		}
	}

	return OptOutput{true, bm[0], steps}, nil
}
